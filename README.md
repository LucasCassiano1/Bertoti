# bertoti
 
TEXTO: We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.

Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.

Comentário:

O texto destaca que a principal diferença entre programação e engenharia de software está em três aspectos: tempo, escala e trade-offs. Na engenharia de software, há uma maior preocupação com a passagem do tempo e a necessidade de mudanças, a eficiência e a escalabilidade tanto do software quanto da organização. Além disso, as decisões são mais complexas e arriscadas, baseadas em estimativas imprecisas. No Google, considera-se que "engenharia de software é programação integrada ao longo do tempo", ressaltando que a programação é apenas uma parte da engenharia de software, que também inclui desenvolvimento, modificação e manutenção. Assim, engenharia de software envolve uma dimensão adicional que vai além da programação pura.

Exemplos de trade-off:

Tempo e Qualidade Apressar o desenvolvimento para cumprir prazos pode resultar em menor qualidade, com mais bugs e problemas. Focar na qualidade, com testes e revisões rigorosas, pode atrasar a entrega do produto.

Desempenho e Custo Melhorar o desempenho de um software pode exigir hardware mais caro ou mais horas de desenvolvimento, aumentando os custos. Reduzir custos pode significar aceitar um desempenho inferior.

Funcionalidade e Simplicidade Adicionar muitas funcionalidades pode tornar o software complexo e difícil de usar. Manter a simplicidade pode limitar a quantidade de funcionalidades, mas resulta em um produto mais intuitivo e fácil de manter.uncionalidades pode tornar o software complexo e difícil de usar. Manter a simplicidade pode limitar a